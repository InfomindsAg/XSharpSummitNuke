using Serilog;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Nuke.Common;
using Nuke.Common.CI;
using Nuke.Common.Execution;
using Nuke.Common.IO;
using Nuke.Common.ProjectModel;
using Nuke.Common.Tooling;
using Nuke.Common.Tools.DotNet;
using Nuke.Common.Tools.MSBuild;
using Nuke.Common.Tools.VSTest;
using Nuke.Common.Utilities.Collections;
using static Nuke.Common.EnvironmentInfo;
using static Nuke.Common.IO.FileSystemTasks;
using static Nuke.Common.IO.PathConstruction;
using static Nuke.Common.Tools.Git.GitTasks;
using static Nuke.Common.Tools.MSBuild.MSBuildTasks;
using System.ComponentModel;

class Build : NukeBuild
{

    public static int Main() => Execute<Build>(x => x.Compile);


    private bool IsUnitTestProject(string name)
        => name.EndsWith(".Tests", StringComparison.CurrentCultureIgnoreCase);

    #region Paths
    protected virtual AbsolutePath GetAssetsFromDirectory => (AbsolutePath)@"C:\TempXSharp\Assets\";

    protected AbsolutePath LocalAssetsDirectory => Solution.Directory / "assets";

    [Parameter("Directory for code analysis output")]
    public readonly AbsolutePath CodeAnalysisDirectory = RootDirectory / "analysis";

    [Parameter("Directory for publish output and logs")]
    public readonly AbsolutePath PublishDirectory = RootDirectory / "publish";

    [Parameter("Directory for extra output like changelogs, ...")]
    public readonly AbsolutePath PublishExtraDirectory = RootDirectory / "publish_extra";

    [Parameter("Directory for extra output like buildlogs, ...")]
    public virtual AbsolutePath BuildLogDirectory => PublishDirectory / "logs";

    [Parameter("Directory for sourcecode")]
    public virtual AbsolutePath SourceDirectory => RootDirectory / "src";
    #endregion

    /// <summary>Defines, if the solution contains UnitTests</summary>
    protected virtual bool UnitTestsAvailable => Solution.AllProjects.Any(q => IsUnitTestProject(q.Name));

    [Parameter("Configuration to build - Default is 'Debug' (local) or 'Release' (server)")]
    public Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;

    [Parameter("Specify the verbosity for the execution of the unit-tests. Allowed values Quiet, Minimal, Normal, Detailed, Diagnostic.")]
    public readonly DotNetVerbosity TestVerbosity = DotNetVerbosity.Normal;

    [Parameter("Specify the .NET Framework for the execution of the unit-tests. default: net472")]
    public readonly string TestNetFrameWork = "net472";

    [Solution]
    public Solution Solution { get; } = null;

    #region Targets
    Target ChangeLog => _ => _
        .Description("Creates the git changelog file.")
        .Executes(ChangeLogAction);

    Target Clean => _ => _
        .Description("Deletes the files generated by building the solution")
        .Before(Restore)
        .Executes(() =>
        {
            PublishDirectory.CreateOrCleanDirectory();
            PublishExtraDirectory.CreateOrCleanDirectory();
            SourceDirectory.GlobDirectories("**/bin", "**/obj").ForEach(q => q.DeleteDirectory());
        });

    Target CodeAnalysis => _ => _
        .Description("Analzyes the code and saves the output in the analysis Directory")
        .Executes(CodeAnalysisAction);

    Target GetAssets => _ => _
        .Description("Updates the files in the assets directory.")
        .Executes(() =>
        {
            LocalAssetsDirectory.CreateOrCleanDirectory();
            if (!string.IsNullOrEmpty(GetAssetsFromDirectory))
                Assert.DirectoryExists(GetAssetsFromDirectory, $"Directory {GetAssetsFromDirectory} is not available");
            var (copied, removed) = SyncFiles(GetAssetsFromDirectory, LocalAssetsDirectory, true);
            if (copied != 0 || removed != 0)
                Log.Information("Assets are up to date");
            else
                Log.Information("No remote Assets Directory defined");
        }
        );

    Target Restore => _ => _
        .Description("Executes the restore for the solution.")
        .Executes(() =>
        {
            MSBuild(_ => _
            .SetTargetPath(Solution)
            .SetTargets("Restore")
            .SetVerbosity(MSBuildVerbosity.Quiet));
        });

    Target Compile => _ => _
        .Description("Builds the solution")
        .DependsOn(Restore)
        .Executes(() =>
        {
            MSBuild(s => s
                .SetTargetPath(Solution)
                .SetTargets("Build")
                .SetConfiguration(Configuration)
                .SetMaxCpuCount(Environment.ProcessorCount)
                .SetVerbosity(MSBuildVerbosity.Quiet)
                .SetNodeReuse(IsLocalBuild));
        });

    Target ReCompile => _ => _
        .Description("Rebuilds the solution")
        .DependsOn(Clean, Restore, GetAssets)
        .Executes(() =>
        {
            var buildLogFileName = Solution.Directory / "msbuild.binlog";

            try
            {

                MSBuild(s => s
                    .SetTargetPath(Solution)
                    .SetTargets("Rebuild")
                    .SetConfiguration(Configuration)
                    .SetMaxCpuCount(Environment.ProcessorCount)
                    .SetVerbosity(MSBuildVerbosity.Quiet)
                    .SetNodeReuse(IsLocalBuild));

                File.Delete(buildLogFileName);
            }
            catch
            {
                if (buildLogFileName.FileExists() && !string.IsNullOrEmpty(BuildLogDirectory))
                    CopyFile(buildLogFileName, BuildLogDirectory / "msbuild.binlog");

                throw;
            }
        });


    Target Publish => _ => _
        .Description("Publishes the solution to the specified publish folder")
        .DependsOn(Clean, Restore)
        .Executes(PublishAction);

    Target Test => _ => _
                .Description("Executes the xUnit-Tests from all test-projects in the current solution")
                .OnlyWhenStatic(() => UnitTestsAvailable)
                .Executes(TestAction);

    Target CompileAndTest => _ => _
                .Description("Compiles the solution and executes the xUnit-Tests from all test-projects in the current solution")
                .DependsOn(Compile, Test)
                .Executes(() => { });
    #endregion

    #region BuildActions
    protected virtual void ChangeLogAction()
    {
        var changeLogFileName = PublishExtraDirectory / $"changelog_{Solution.Name}.txt";
        if (!changeLogFileName.Parent.Exists())
            changeLogFileName.Parent.CreateDirectory();

        if (!string.IsNullOrEmpty(PublishExtraDirectory))
            Assert.DirectoryExists(PublishExtraDirectory, $"Directory {PublishExtraDirectory} is not available");

        var args = "--no-pager log -100 --date=\"format-local:%d-%m-%Y %H:%M:%S\" --pretty=format:\"%cd: %s (%cn)\"";
        var output = Git(args, logOutput: false, workingDirectory: null);
        File.WriteAllText(changeLogFileName, string.Join(Environment.NewLine, output.Select(q => q.Text)));

        Log.Information("Changelog {changeLogFileName} created", changeLogFileName);
    }

    protected virtual void CodeAnalysisAction()
    {
        if (!CodeAnalysisDirectory.Exists())
            CodeAnalysisDirectory.CreateDirectory();

        Log.Information("Performing Code Analysis");
    }

    protected virtual void PublishAction()
    {
        MSBuild(s => s
            .SetTargetPath(Solution)
            .SetTargets("Rebuild")
            .SetConfiguration(Configuration)
            .SetMaxCpuCount(Environment.ProcessorCount)
            .SetNodeReuse(IsLocalBuild)
            .SetProcessArgumentConfigurator(a => a
                .Add("/p:TreatWarningsAsErrors=true", true)) // Treat all Warnings as Errors for Publish
            .SetOutDir(PublishDirectory)
            .SetVerbosity(MSBuildVerbosity.Minimal));
    }

    protected virtual void TestAction()
    {
        foreach (var testProject in Solution.AllProjects.Where(p => IsUnitTestProject(p.Name)))
        {
            Log.Information($"--------- Performing Unit-Tests for project {testProject.Name} ---------");

            var results = DotNetTasks.DotNetTest(_ => _
                .SetProjectFile(testProject)
                .SetConfiguration(Configuration)
                .SetFramework(TestNetFrameWork)
                .SetVerbosity(TestVerbosity)
                .EnableNoBuild()
                );
            Log.Information(String.Join(Environment.NewLine, results.Select(q => q.Text)));
        }
    }
    #endregion

    #region HelperMethods
    private static (int copied, int removed) SyncFiles(AbsolutePath sourcePath, AbsolutePath destinationPath, bool removeNotExistingFilesFromDestination)
    {
        Assert.NotNullOrEmpty(sourcePath, "Source Directory can not be empty");
        Assert.NotNullOrEmpty(destinationPath, "Destination Directory can not be empty");
        var copied = 0;
        var removed = 0;

        foreach (var sourceFileName in sourcePath.GlobFiles("**/*.*"))
        {
            var destinationFileName = destinationPath / Path.GetRelativePath(sourcePath, sourceFileName);

            var copyFile = !destinationFileName.FileExists();
            if (!copyFile)
            {
                var sourceFileInfo = new FileInfo(sourceFileName);
                var destinationFileInfo = new FileInfo(destinationFileName);
                copyFile = (sourceFileInfo.LastWriteTime != destinationFileInfo.LastWriteTime) ||
                           (sourceFileInfo.Length != destinationFileInfo.Length);
            }

            if (copyFile)
            {
                CopyFile(sourceFileName, destinationFileName, FileExistsPolicy.Overwrite);
                copied++;
            }
        }

        if (removeNotExistingFilesFromDestination)
        {
            foreach (var destinationFileName in destinationPath.GlobFiles("**/*.*"))
            {
                var remoteFileName = sourcePath / Path.GetRelativePath(destinationPath, destinationFileName);
                if (!remoteFileName.FileExists())
                {
                    destinationFileName.DeleteFile();
                    removed++;
                }
            }
            foreach (var destinationDirName in destinationPath.GlobDirectories("**/*"))
            {
                var remoteDirName = sourcePath / Path.GetRelativePath(destinationPath, destinationDirName);
                if (!remoteDirName.DirectoryExists())
                    destinationDirName.DeleteDirectory();
            }
        }
        return (copied, removed);
    }
    #endregion
}
